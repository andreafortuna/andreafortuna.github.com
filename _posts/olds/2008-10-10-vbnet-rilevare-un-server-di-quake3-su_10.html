---
layout: post
title: 'VB.NET: rilevare un server di Quake3 su una rete locale'
date: '2008-10-10T22:55:00.001+02:00'
author: Andrea Fortuna
tags:
- VB.NET
- Programmazione
- Quake III Arena
- Multiplayer
modified_time: '2012-04-26T14:20:32.828+02:00'
blogger_id: tag:blogger.com,1999:blog-1948348952555789070.post-9149023036933251496
blogger_orig_url: http://oldsite.andreafortuna.org/2008/10/vbnet-rilevare-un-server-di-quake3-su_10.html
---

Classica applicazione inutile ma divertente da sviluppare :-)<br/><br/><a href="http://andreafortuna.files.wordpress.com/2008/10/q3logo.png"><img class="size-full wp-image-1151 alignright" title="q3logo" src="http://andreafortuna.files.wordpress.com/2008/10/q3logo.png" alt="" width="105" height="102" /></a>Qualche giorno fa ho iniziato a chiedermi come il mio amato Quake3 Arena lavorasse per ricercare i server per il gioco in multiplayer sulla rete locale.<br/><br/>Dopo una breve ricerca su Google mi sono imbattuto in <a href="http://www.tilion.org.uk/Games/Quake_3/Network_Protocol">questo articolo</a> che spiega a grandi linee come funziona il protocollo utilizzato dal motore di Q3A: tutto basato su UDP (scelta obbligata, per la maggiore velocità) e a dire il vero abbastanza semplice e lineare.<br/><blockquote>To query a server is very simple. Send a connectionless (UDP) packet with 4 OOB header bytes (0xff) and the text string getstatus. There are many sites which contain a thorough description of this so I won't go into details.</blockquote><br/>Quindi, per rilevare se su una macchina remota sia attivo un server è sufficiente forgiare un pacchetto UDP come descritto sopra, inviarlo sulla porta 27960 e attendere una eventuale risposta (non all'infinito, essendo UDP un protocollo 'connection-less').<br/><br/>Con queste informazioni la realizzazione di una semplice funzione in VB.NET è cosa da poco:<br/><br/>[sourcecode language='vb']<br/><br/>Imports System.Net<br/><br/>Public Function CheckServer(ByVal hostaddress As String)<br/>        Dim _UdpClient As New System.Net.Sockets.UdpClient<br/><br/>        Dim client As New Sockets.Socket(Sockets.AddressFamily.InterNetwork, Sockets.SocketType.Dgram, Sockets.ProtocolType.Udp)<br/><br/>        client.ReceiveTimeout = 5<br/>        client.Connect(IPAddress.Parse(hostaddress), 27960)<br/><br/>        Dim bytCommand As Byte() = System.Text.Encoding.ASCII.GetBytes("xxxxxgetstatus")<br/>        bytCommand(0) = Byte.Parse("255")<br/>        bytCommand(1) = Byte.Parse("255")<br/>        bytCommand(2) = Byte.Parse("255")<br/>        bytCommand(3) = Byte.Parse("255")<br/>        bytCommand(4) = Byte.Parse("02")<br/><br/>        Dim remoteEndPoint As New IPEndPoint(IPAddress.Any, 0)<br/><br/>        Dim pret As String = client.Send(bytCommand, socketFlags:=Sockets.SocketFlags.None)<br/>        Dim bufferRec(65000) As Byte<br/>        Try<br/>            client.Receive(bufferRec)<br/>            Return System.Text.Encoding.ASCII.GetString(bufferRec)<br/><br/>        Catch ex As Exception<br/>            Return ""<br/>        End Try<br/><br/>    End Function<br/><br/>[/sourcecode]<br/><br/>Da notare che ho settato manualmente il timeout della connessione e 'trappato' l'errore di connessione, verificando in questo modo se il server sia in funzione o meno.<br/><br/>La funzione mi restituisce una stringa contenente (qualora sia attivo un server sulla macchina esaminata) una serie di informazioni sulla partita in corso; nel caso la connessione vada in timeout, restituisce una stringa vuota.<br/><br/>Ora so verificare se su un determinato sistema stia girando Q3A in modalità multiplayer, il passo successivo è ripetere questa procedura per tutti quelli presenti sulla mia rete locale.<br/><br/>Per farlo questo mi sono affidato a una soluzione 'sporca' ma funzionale: utilizzo il comando 'net view' di windows, ne analizzo il risultato ottenendo un elenco di indirizzi:<br/><br/>[sourcecode language='vb']<br/><br/>Public Function GetIpAddresses()<br/>        Dim addresses As New ArrayList<br/>        Dim MyAdd As String = Dns.GetHostByName(Dns.GetHostName()).AddressList(0).ToString<br/>        Dim psi As System.Diagnostics.ProcessStartInfo = New System.Diagnostics.ProcessStartInfo()<br/>        psi.FileName = ("C:\WINDOWS\System32\cmd.exe")<br/>        psi.Arguments = "/c net view > lista.txt"<br/>        psi.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden<br/>        Application.DoEvents()<br/>        System.Diagnostics.Process.Start(psi)<br/>        Dim sr As System.IO.StreamReader = Nothing<br/>        Dim run As Boolean = False<br/>        While run = False<br/>            Application.DoEvents()<br/>            Try<br/>                System.Threading.Thread.Sleep(1000)<br/>                sr = New System.IO.StreamReader(Application.StartupPath & "\lista.txt")<br/>                run = True<br/><br/>            Catch ex As Exception<br/>                run = False<br/>            End Try<br/>        End While<br/><br/>        While sr.ReadLine().StartsWith("--")  True<br/>            Application.DoEvents()<br/>        End While<br/><br/>        Dim str As String = ""<br/>        Dim comp(64) As String<br/>        Dim i As Integer = 0<br/><br/>        While str.StartsWith("The")  True<br/>            Application.DoEvents()<br/>            str = sr.ReadLine<br/>            comp(i) = str.Split(Char.Parse(" "))(0)<br/>            comp(i) = comp(i).Substring(2, comp(i).Length - 2)<br/>            If comp(i) = "e" Then<br/>                Application.DoEvents()<br/>                comp(i) = Nothing<br/>            End If<br/>            i = i + 1<br/>        End While<br/>        sr.Close()<br/>        sr = Nothing<br/>        For Each s As String In comp<br/>            If s  Nothing Then<br/>                If s.ToUpper  Dns.GetHostName.ToUpper Then<br/>                   addresses.Add(Dns.GetHostByName(s).AddressList(0).ToString)<br/>                End If<br/>            End If<br/>        Next<br/>        Return addresses<br/>    End Function<br/><br/>[/sourcecode]<br/><br/>a questo punto non mi resta che sottoporre l'array di indirizzi restituito dalla funzione GetIpAddresses a CheckServer e, se viene rilevato un server, leggere i dati restituiti e formattarli adeguatamente:<br/><br/>[sourcecode language='vb']<br/><br/> Dim lista As ArrayList = GetIpAddresses()        <br/><br/>        For Each riga As String In lista.ToArray<br/>            Dim server As String = CheckServer(riga)<br/>            If server  "" Then<br/>                Dim ServerName As String = server.Split("\")(Array.IndexOf(server.Split("\"), "sv_hostname") + 1)<br/>                Dim MapName As String = server.Split("\")(Array.IndexOf(server.Split("\"), "mapname") + 1)<br/>                Dim FragLimit As String = server.Split("\")(Array.IndexOf(server.Split("\"), "fraglimit") + 1)<br/>                Dim TimeLimit As String = server.Split("\")(Array.IndexOf(server.Split("\"), "timelimit") + 1)<br/>                Dim Version As String = server.Split("\")(Array.IndexOf(server.Split("\"), "version") + 1)<br/><br/>                risultato = risultato & "--- Trovato Server ---" & vbCrLf<br/>                risultato = risultato & "Ip Address:" & riga & vbCrLf<br/>                risultato = risultato & "Server Name: " & ServerName & vbCrLf<br/>                risultato = risultato & "Mappa: " & MapName & vbCrLf<br/>                risultato = risultato & "FragLimit: " & FragLimit & vbCrLf<br/>                risultato = risultato & "TimeLimit: " & TimeLimit & FragLimit & vbCrLf<br/>                risultato = risultato & "Versione: " & Version & FragLimit & vbCrLf<br/><br/>                TextBox1.Text =  TextBox1.Text  & risultato<br/>            End If<br/>            Application.DoEvents()<br/>        Next   <br/>    End Sub<br/><br/>[/sourcecode]<br/><br/>Ho completato il tutto con il codice necessario a ridurre l'applicazione nella system tray (facendo ripetere la procedura di scan ogni 5 secondi) e a far riapparire un form qualora la ricerca fornisca esito positivo.<br/><br/>Il sorgente completo è scaricabile da <a href="http://andrea.fortuna.googlepages.com/UnaScan.zip">QUI</a>.<br/><br/>(e sperate che non finisca mai tra le mani del vostro capoufficio!) :-D