---
layout: post
title: OS Fingerprinting
date: '2006-01-13T10:01:00.001+01:00'
author: Andrea Fortuna
tags:
- Security
modified_time: '2012-04-26T14:24:31.121+02:00'
blogger_id: tag:blogger.com,1999:blog-1948348952555789070.post-5273288428517553066
blogger_orig_url: http://www.andreafortuna.org/2006/01/os-fingerprinting_13.html
---

<p>Determinare il sistema operativo di una macchina avendo la possibilita' di accedervi e' una procedura relativamente semplice; piu' complicata da realizzare e' invece l'identificazione del S.o. <em>dall'esterno</em>.</p><p>l'<em>OS Fingerprinting</em> e' una tecnica in grado di determinare con probabilita' molto elevata il sistema operativo di un certo host attraverso l'analisi di particolari informazioni e caratteristiche fornite dallo stesso.</p><a name='more'></a><p>Esistono diverse tecniche di Fingerprinting, implementate da diversi programmi; uno dei tool piu' noti e' sicuramente il network scanner <a href="http://www.insecure.org/nmap/" target="_blank">Nmap</a>, 'creatura' dell'hacker <em>Fyodor, </em>che tra le sue molteplici funzionalita' include anche delle routine di OS Fingerprinting.</p><p>Le tecniche di Fingerprinting implementate da Nmap sono diverse e tutte basate sull'analisi dello stack del protocollo TCP/IP: per questo motivo, per comprendere appieno i concetti trattati in questo articolo occorre conoscere alcuni dettagli di questo protocollo (oramai, chi non li conosce?? :-P).</p><p>In breve possiamo dire che qualsiasi connessione TCP/IP tra due sistemi viene instaurata seguendo un meccanismo noto come <em>3-Way Hand-Shake</em> (che puo' essere tradotto come <em>stretta di mano "a tre vie"</em>).</p><p> <img height="137" alt="" src="http://www.andreafortuna.net/wp-content/3-way.jpg" width="252" border="0" /></p><p>Il client deve sincronizzarsi col server prima di iniziare a trasmettere dati, di conseguenza manda un pacchetto di tipo SYN, che contiene anche un certo numero X (generato in maniera casuale) detto ISN (<em>Initial Sequence Number</em>).</p><p>Il server risponde al client con un pacchetto di tipo SYN/ACK, nel quale dimostra di aver ricevuto il primo pacchetto spedendo una risposta (<em>Acknowledgement</em>) che corrisponde al numero iniziale incrementato (X+1); nello stesso tempo il server genera un proprio numero casuale (Y) e lo invia al client.</p><p>La procedura si conclude quando il client risponde al server con un messaggio conclusivo di tipo ACK che contiene a sua volta il numero Y incrementato di una unita'. A questo punto la sincronizzazione e' conclusa e i due sistemi possono iniziare a scambiare dati.</p><p>L'<a href="http://www.faqs.org/rfcs/rfc793.html" target="_blank">RFC793</a> detta proprio le specifiche di questo meccanismo, che nella realta' viene implementato in maniera leggermente differente da ciascun sistema operativo: la sostanza non cambia, tuttavia le scelte di implementazione dei costruttori (Microsoft, Sun, HP, RedHat, Cisco ecc..) sono molteplici e sono le chiavi per distinguere un sistema operativo da un'altro.</p><p>Il modo in cui viene generato il numero casuale ISN e' diverso da sistema a sistema: ad esempio nelle vecchie versioni di Windows veniva generato con un metodo <em>tempo-dipendente</em>, suscettibile ad attacchi di <em>IP-Spoofing.</em> Il problema e' stato risolto e il metodo di generazione del SYN e' stato viavia migliorato, fino a quello utilizzato in <a href="http://www.microsoft.com/technet/prodtechnol/windowsserver2003/technologies/networking/tcpip03.mspx" target="_blank">Windows Server 2003</a>:</p><blockquote><p><!--StartFragment --> Windows Server 2003 TCP/IP has also been strengthened against a variety of attacks that were published over the past couple of years and has been subject to an internal security review intended to reduce susceptibility to future attacks. For instance, the initial sequence number (ISN) algorithm has been modified so that ISNs increase in random increments, using an RC4-based random number generator initialized with a 2048-bit random key upon system startup. </p></blockquote><p>Le principali tecniche di identificazione sono quindi basate sull'analisi dello stack TCP/IP e delle risposte fornite dall'host remoto in presenza di pacchetti "strani" o condizioni non contemplate dalle specifiche dell'RFC793, condizioni che vengono gestite in maniera diversa da ciascun sistema operativo.</p><p>Alcuni dei principali metodi di identificazione (in realta' sono molto piu' numerosi, cito i piu' noti/interessanti):</p><p><strong>FIN probe</strong>Viene spedito un pacchetto di tipo FIN su una porta aperta e si attende la risposta dell'host. L'RFC793 specifica di non rispondere al pacchetto, tuttavia alcune implementazioni rispondono con un RST (Windows, CISCO, HP/UX, IRIX, MVS).</p><p><strong>BOGUS flag probe</strong>Viene impostato un flag TCP indefinito (bit 7 o 8, contando da sinistra) nell'header TCP di un pacchetto SYN inviato all'host.I sistemi linux con kernel precedente al 2.0.35 mantengono tale flag inalterato anche nelle successive risposte.Negli ultimi aggiornamenti del protocollo, pero', i bit 8 e 9 sono stati impiegati come field ECN per il controllo della congestione.</p><p><strong>ISN sampling</strong>Vengono identificati pattern e regolarita' nella generazione dei numeri ISN fatta dai sistemi operativi nelle diverse implementazioni dello stack TCP.Come gia' trattato, quando un host riceve un messaggio di SYN, genera in maniera pseudo-casuale un proprio numero ISN in risposta al pacchetto.Inviando diversi pacchetti SYN e' possibile calcolare di quanto differiscono tra loro i diversi numeri ISN generati dall'host remoto e verificare quanto essi siano casuali.</p><p><strong>TCP Timestamp</strong>Viene analizzato il valore dell'opzione TCP Timestamp. Alcuni sistemi non supportano questa funzionalita', altri ne incrementano il valore a varie frequenze (2HZ, 100HZ, o 1000HZ), altri restituiscono semplicemente 0.Nmap utilizza queste informazioni per determinare anche il tempo di <em>uptime</em> dell'host remoto.</p><p><strong>TCP Initial Window</strong>Viene analizzato il valore di <em>Window Size</em> nell'Header TCP.Il Window Size e' <!--StartFragment -->campo di 16 bit, contenente la dimensione del buffer di dati che il mittente puo' accettare, ed e' un valore costante per ogni sistema operativo. Questo test fornisce attualmente parecchie informazioni, in quanto alcuni sistemi operativi possono essere identificati solamente dal <em>window size</em> (ad esempio, AIX e' l'unico S.o. ad utilizzare il valore 0x3F25).Una piccola curiosita': Microsoft, nell'ultima versione del suo stack TCP realizzata per i sistemi &gt;NT5, utilizza come <em>window size</em> il valore 0x402E. Strano, visto che e' lo stesso identico valore utilizzato negli stack dei sistemi OpenBSD e FreeBSD :-).</p><p><img height="285" alt="" src="http://www.andreafortuna.net/wp-content/OS_fingerprint.jpg" width="538" border="0" /></p>