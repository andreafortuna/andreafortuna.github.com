<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-aRcVnxJiFJg/UZ3XubIOcZI/AAAAAAAAFHw/VBI5FmK0V54/s1600/images.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="200" src="http://4.bp.blogspot.com/-aRcVnxJiFJg/UZ3XubIOcZI/AAAAAAAAFHw/VBI5FmK0V54/s200/images.jpg" width="200" /></a></div>La ricerca binaria si effettua suddividendo l'array in pezzi sempre più piccoli fino a quando non si trova il valore desiderato, a&nbsp;differenza della ricerca sequenziale implementata da&nbsp;<i>indexOf</i>&nbsp; che scorre l'array da sinistra a destra in una semplice iterazione.<br /><br />L'operazione deve essere effettuata su un array ordinato, e mediamente utilizza meno confronti rispetto alla ricerca sequenziale, portando a termine la ricerca in meno tempo.<br /><br /><br /><a name='more'></a><br /><br />Per quanto riguarda le prestazioni, cito <a href="http://it.wikipedia.org/wiki/Ricerca_dicotomica" target="_blank">Wikipedia</a>:<br /><blockquote class="tr_bq">La ricerca binaria non usa mai più di <span id="goog_2036252412"></span><img src="http://upload.wikimedia.org/math/0/9/e/09e4fd8229e9ee576b4e8e6339c5e59f.png" /><span id="goog_2036252413"></span> (logaritmo base 2 di N approssimato per eccesso) confronti per una search hit o una search miss. Tuttavia, a meno che non si controllino ad ogni iterazione i valori dei due indici estremi, la ricerca binaria impiega effettivamente sempre lo stesso tempo su uno stesso array per cercare elementi anche in posizioni diverse; la ricerca sequenziale invece passa da O(n) come caso peggiore a O(n/2) nel caso medio, fino a O(1) se l'elemento si trova in prima posizione.</blockquote><br /><br />Nel semplice demo che ho realizzato, ho esteso la classe <i>Array</i>&nbsp;aggiungendo il metodo <i>binaryIndexOf</i>:<br /><br /><iframe allowfullscreen="allowfullscreen" frameborder="0" height="550" src="http://jsfiddle.net/V2kTY/embedded/" width="100%"></iframe>