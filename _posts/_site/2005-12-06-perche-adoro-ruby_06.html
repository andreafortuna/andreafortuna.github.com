<p>Ruby è un linguaggio object-oriented originato in Giappone, e qui molto diffuso, ad opera di Yukihiro Matsumoto nel 1993 (la release 1.0 risale pero' al 1996). </p><p>Il nome Ruby si rifà a Perl, in italiano rispettivamente <em>rubino </em>e <em>perla</em>.  <a name='more'></a></p><p> Ruby è facile da imparare anche per chi non ha mai scritto una riga di software - questa è una grossa differenza rispetto a tutti gli altri linguaggi (object-oriented e non); </p><p>In breve: </p><li>Ruby è sintetico come Perl ma non è criptico come Perl; </li>   	  <li>Ruby è facile e pulito come Python ma non costringe a "squadrare" i listati come Python (ed ha molte più features di Python); </li>   	  <li>Ruby è object-oriented come Eiffel, ma non è "logorroico" e ultraridondante come Eiffel; </li>   	  <li>Ruby fa il 99% delle cose che si fanno in C++ e Java ma senza nessuna delle complicazioni mentali del C++ e senza il rigorismo sintattico di Java; </li>   	  <li>Ruby è object-oriented come SmallTalk, ma non è criptico ed esotico come SmallTalk;</li>   	  <li>Ruby ha dynamic types alla faccia di quelli statici di C#, C++, etc; </li>   	  <li>Ruby include le funzionalità della shell, di awk, sed, grep... (quante righe ci vogliono in C++ o Java per matchare un'espressione regolare?) </li>   	  <li>Ruby è veramente object-oriented, per cui nello scrivere software ci si concentra su quel che c'è da fare piuttosto che sul "come trovare un modo per fare quel che c'è da fare" (ciò che succede praticamente sempre se si usa il linguaggio C, Pascal, etc). </li> <p> In Ruby tutto e' un oggetto, anche i semplici numeri; </p> <p>quindi per farsi calcolare i quadrati dei numeri da 0 a 14 possiamo scrivere </p>   <blockquote>    <p>15.times { |x| puts x*x } </p>  </blockquote>   <p>Dato che "15" è un oggetto della classe Number, allora gli si può applicare il metodo times e passargli un blocco di codice. </p> <p>Nell'iterazione, il valore corrente verrà chiamato x (ecco il significato di quel |x|). </p> <p>Altri esempi...aggiungere il numero di riga a ogni linea in arrivo dallo <em>Standard Input</em> e stamparla a schermo: </p>   <blockquote>    <p>$stdin.each_line { |a| printf ARGV[0]+"%s", $stdin.lineno, a } </p>  </blockquote>   <p>oppure aggiungere a ogni riga in arrivo dallo Standard Input una stringa specificata da riga di comando e stamparla a schermo: </p> <p>   </p>   <blockquote>   <div align="left">$stdin.each_line { |a| print a.chomp, ARGV[0], "n" } </div> </blockquote>   <p>   Un algoritmo di <em>QuickSort:</em></p> <p> </p>   <blockquote> def qsort l                      # in input prende un array     return [] if l.size == 0       # ritorna vuota se era vuoto     x, r = *l                      # x=pivot, r=resto della lista     a, b = r.partition{|i| i    <p>    Convertire ogni carattere di una stringa con il suo equivalente xor:  </p>   <blockquote>    <p>def cambiami str    b = []    str.each_byte { |x| b   </blockquote>   <p> </p> <p>    Lettura di un file <em>.INI</em>:  </p>   <blockquote>    <p>def fileini cfgfile     fail "file non trovato: #{cfgfile}"  unless FileTest.exists? cfgfile    cfg = Hash.new     File.open(cfgfile).each_line do |x|  # per ogni riga x del file:      x.chomp!                           # elimina CR/LF     x.gsub! /s*#.*$/, ""              # elimina i commenti     x.sub! /s*=s*/, "="              # elimina eventuali spazi attorno a '='     ch = x.split "=",2                 # splitta chiave e valore attorno a '='     cfg.store *ch  if ch.length == 2   # aggiungi chiave e valore se entrambe    end   cfg   end   </p>  </blockquote>   <p><em /><em> </em></p><em> </em><p><em /><em /><em /><em> </em></p><em /><em /><em> </em><p><em /><em /><em /><em /><em /><em /><em /><em>(Tutti gli esempi sono tratti da <a href="http://www.alfonsomartone.itb.it/qqvaqs.html">http://www.alfonsomartone.itb.it/qqvaqs.html</a>)</em></p>